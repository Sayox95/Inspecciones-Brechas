<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <link rel="icon" href="data:,">
  <title>Captura de Brechas (MÃ³vil) â€” Refactor 2025-10 v3</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    :root{
      --bg:#0b1220;--card:#0f182a;--muted:#8aa0b6;--text:#ecf3ff;
      --accent:#4cc9f0;--ok:#22c55e;--warn:#f97316;--danger:#ef4444;
      --border:#1d2a45;--sheet:#0b1220;--radius:16px;--shadow:0 10px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box} html,body{height:100%}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial;
      background:var(--bg);color:var(--text);overflow:hidden}
    header{position:fixed;top:0;left:0;right:0;z-index:10;
      display:flex;align-items:center;gap:10px;
      background:rgba(11,18,32,.9);backdrop-filter:blur(8px);
      border-bottom:1px solid var(--border);padding:12px 14px}
    header h1{margin:0;font-size:16px}
    header .muted{color:var(--muted);font-size:12px}
    #map{position:absolute;inset:52px 0 0 0}
    .fab{position:fixed;right:16px;bottom:16px;z-index:1100;
      border:0;border-radius:999px;background:var(--accent);color:#051423;
      padding:14px 16px;font-weight:800;box-shadow:var(--shadow);}
    .fab:active{transform:translateY(1px)}
    .fab[disabled]{opacity:.6;pointer-events:none}

    /* Bottom Sheet */
    .sheet{position:fixed;left:0;right:0;bottom:-100%;z-index:2000;
      background:var(--sheet);border-top-left-radius:20px;border-top-right-radius:20px;
      border:1px solid var(--border);box-shadow:0 -12px 30px rgba(0,0,0,.45);
      transition:bottom .28s ease;max-height:82vh;display:flex;flex-direction:column}
    .sheet.open{bottom:0}
    .sheet .drag{width:56px;height:5px;border-radius:999px;background:#24314f;margin:8px auto}
    .sheet .content{padding:12px;overflow:auto}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .field{display:flex;flex-direction:column;gap:6px}
    label{font-size:12px;color:var(--muted)}
    input[type="text"],select,input[type="file"]{
      width:100%;background:#0e1729;color:var(--text);
      border:1px solid #1f2c49;border-radius:12px;padding:10px 12px;font-size:14px
    }
    .btn{appearance:none;border:0;border-radius:12px;padding:12px 14px;
      background:#183055;color:#e6f0ff;width:100%;font-weight:700}
    .btn[disabled]{opacity:.6;pointer-events:none}
    .btn-primary{background:var(--accent);color:#051423}
    .btn-ok{background:var(--ok);color:#06240e}
    .btn-warn{background:var(--warn);color:#2b0d02}
    .btn-ghost{background:#0e1729;border:1px solid #203153;color:#d7e5ff}
    .btn-danger{background:var(--danger);}
    .bar{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .chips{display:flex;gap:8px;flex-wrap:wrap}
    .chip{padding:6px 10px;border-radius:999px;background:#0e1729;border:1px solid #22355c;font-size:12px;color:var(--muted)}
    .color-box{width:12px;height:12px;border-radius:3px;display:inline-block;margin-right:6px;vertical-align:middle}
    .apertura{background:var(--warn)} .limpieza{background:var(--ok)}
    .muted{color:var(--muted)} .note{font-size:12px;color:var(--muted)}
    .hidden{display:none!important}

    /* Summary card */
    .card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:10px}
    .grid{display:grid;gap:8px}
    img.preview{width:160px;height:auto;object-fit:cover;border-radius:10px;border:1px solid var(--border);cursor:pointer;transition:transform .2s ease}
    img.preview:hover{transform:scale(1.05)}

    /* Popup content */
    .popup-title{font-weight:800;margin-bottom:4px}
    .popup-meta{font-size:12px;color:#9fb3c7}
    .popup-img{width:200px;max-width:80vw;border-radius:10px;margin-top:6px;border:1px solid #1f2c49}

    .pending-banner{position:fixed;left:0;right:0;bottom:0;z-index:1500;
      background:#2a1d0b;color:#ffe7c2;border-top:1px solid #4b2e0f;
      padding:8px 12px;font-size:13px;display:none}
    .pending-banner strong{color:#ffd39a}

    /* Fullscreen blocker */
    .blocker{
      position:fixed; inset:0; z-index:3000;
      display:none; align-items:center; justify-content:center;
      background:rgba(5,10,20,.55); backdrop-filter:blur(2px);
    }
    .blocker .box{
      background:#0e1729; border:1px solid #203153; color:#eaf2ff;
      padding:16px 18px; border-radius:14px; min-width:240px;
      box-shadow:0 10px 30px rgba(0,0,0,.35); text-align:center;
      font-weight:600;
    }
    .spinner{
      width:22px; height:22px; border-radius:50%;
      border:3px solid #29436f; border-top-color:#4cc9f0;
      animation:sp 0.9s linear infinite; display:inline-block; margin-right:10px;
      vertical-align:middle;
    }
    @keyframes sp{to{transform:rotate(360deg);}}

    /* Toast */
    .toast{
      position:fixed; left:50%; bottom:16px; transform:translateX(-50%);
      background:#0e1729; color:#eaf2ff; border:1px solid #203153;
      padding:10px 14px; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.35);
      z-index:4000; display:none; font-weight:600; max-width:90vw; text-align:center;
    }
  </style>
</head>
<body>
  <header>
    <h1>Captura de Brechas</h1>
    <span class="muted">MÃ³vil â€¢ GPS â€¢ Fotos</span>
    <div style="margin-left:auto;display:flex;align-items:center;gap:8px">
      <span id="pendingBadge" class="chip" style="display:none"></span>
      <button id="syncBtn" class="btn btn-ghost" style="padding:8px 10px">ðŸ”„ Sincronizar</button>
    </div>
  </header>

  <div id="map"></div>
  <div id="pendingBanner" class="pending-banner">Tienes <strong id="pendingCount">0</strong> reporte(s) pendientes de sincronizar.</div>

  <!-- Floating Action -->
  <button id="newTramo" class="fab">+ Nuevo tramo</button>

  <!-- Bottom Sheet / Stepper -->
  <section id="sheet" class="sheet" aria-modal="true" role="dialog">
    <div class="drag"></div>
    <div class="content">
      <div id="step-1" class="grid">
        <div class="card">
          <div class="chips" style="margin-bottom:8px">
            <span class="chip"><span class="color-box apertura"></span>Apertura</span>
            <span class="chip"><span class="color-box limpieza"></span>Limpieza</span>
          </div>
          <div class="row">
            <div class="field">
              <label>Sector</label>
              <input id="sector" type="text" placeholder="Ej: Norte">
            </div>
            <div class="field">
              <label>SubestaciÃ³n</label>
              <input id="subestacion" type="text" placeholder="Ej: S/E Progreso">
            </div>
          </div>
          <div class="row">
            <div class="field">
              <label>Circuito</label>
              <input id="circuito" type="text" placeholder="Ej: CIR-123">
            </div>
            <div class="field">
              <label>Tipo de brecha</label>
              <select id="tipo">
                <option value="Apertura">Apertura de brecha</option>
                <option value="Limpieza">Limpieza de brecha</option>
              </select>
            </div>
          </div>
          <div class="note">Completa y pulsa <strong>Siguiente</strong>.</div>
          <div class="bar" style="margin-top:10px">
            <button id="s1-cancel" class="btn btn-ghost">Cancelar</button>
            <button id="s1-next" class="btn btn-primary">Siguiente</button>
          </div>
        </div>
      </div>

      <div id="step-2" class="grid hidden">
        <div class="card grid">
          <div><strong>Paso 2:</strong> Capturar <u>punto inicial</u> y subir <u>foto obligatoria</u>.</div>
          <button id="cap-inicio" class="btn btn-primary">Captar punto inicial (GPS)</button>
          <div class="field">
            <label>Foto punto inicial (requerida)</label>
            <input id="fotoInicio" type="file" accept="image/*" capture="environment">
          </div>
          <div id="previewInicioWrap" class="hidden">
            <img id="previewInicio" class="preview" alt="Foto inicio"/>
          </div>
          <div class="bar">
            <button id="s2-back" class="btn btn-ghost">AtrÃ¡s</button>
            <button id="s2-next" class="btn btn-primary">Siguiente</button>
          </div>
        </div>
      </div>

      <div id="step-3" class="grid hidden">
        <div class="card grid">
          <div><strong>Paso 3:</strong> Capturar <u>punto final</u> y subir <u>foto obligatoria</u>.</div>
          <button id="cap-fin" class="btn btn-primary">Captar punto final (GPS)</button>
          <div class="field">
            <label>Foto punto final (requerida)</label>
            <input id="fotoFin" type="file" accept="image/*" capture="environment">
          </div>
          <div id="previewFinWrap" class="hidden">
            <img id="previewFin" class="preview" alt="Foto final"/>
          </div>
          <div class="bar">
            <button id="s3-back" class="btn btn-ghost">AtrÃ¡s</button>
            <button id="s3-next" class="btn btn-primary">Siguiente</button>
          </div>
        </div>
      </div>

      <div id="step-4" class="grid hidden">
        <div class="card grid">
          <div><strong>Resumen</strong> â€” revisa y guarda.</div>
          <div id="resumen" class="grid"></div>
          <div class="bar">
            <button id="s4-cancel" class="btn btn-ghost">Cancelar</button>
            <button id="s4-save" class="btn btn-ok">Guardar tramo</button>
          </div>
        </div>
      </div>
    </div>
  </section>

  <script>
    "use strict";

    // ====== CONFIG ======
    const APPS_SCRIPT_URL = "/api/sync"; // pega tu URL de Web App para sincronizar

    // ====== MAPA ======
    const map = L.map('map', { zoomControl: true });
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 20, attribution: '&copy; OpenStreetMap'
    }).addTo(map);

    // Centrado inicial a ubicaciÃ³n del usuario (con UX de carga)
    function locate() {
      if (navigator.geolocation) {
        showBlocker('Obteniendo ubicaciÃ³nâ€¦');
        getGPSFast().then((p)=>{
          hideBlocker();
          map.setView([p.lat, p.lng], 17);
        }).catch(()=>{
          hideBlocker();
          map.setView([14.0723,-87.1921], 7);
          toast('No fue posible obtener tu ubicaciÃ³n inicial.');
        });
      } else {
        map.setView([14.0723,-87.1921], 7);
      }
    }
    locate();

    // ====== Estado ======
    const $ = (id)=> document.getElementById(id);
    const sheet = $("sheet");
    let step = 1;
    const state = {
      actual: {
        sector:"", subestacion:"", circuito:"", tipo:"Apertura",
        inicio:null, fin:null, fotoInicio:null, fotoFin:null
      },
      items: [], layers: [],
      mkInicioTemp:null, mkFinTemp:null
    };

    // cargar items de localStorage
    try{ state.items = JSON.parse(localStorage.getItem("brechas_items")||"[]"); }catch(e){ state.items = []; }
    renderAll();
    updatePendingUI();

    // ====== Utiles ======
    function openSheet(){ sheet.classList.add("open"); }
    function closeSheet(){ sheet.classList.remove("open"); setStep(1); clearWizard(false); }
    function show(id){ var el = $(id); if(el) el.classList.remove("hidden"); }
    function hide(id){ var el = $(id); if(el) el.classList.add("hidden"); }
    function setStep(n){
      step = n;
      ["step-1","step-2","step-3","step-4"].forEach(function(s){ hide(s); });
      show("step-"+n);
    }
    function tipoColor(t){ return (t==="Limpieza") ? "#22c55e" : "#f97316"; }
    function addLayer(layer){ state.layers.push(layer); layer.addTo(map); }
    function clearMapLayers(){
      state.layers.forEach(function(l){
        try{ map.removeLayer(l); }catch(_){ /* ignore */ }
      });
      state.layers = [];
    }

    // Imagen: compresiÃ³n agresiva para mÃ³viles (evita desbordar localStorage)
    async function compressImage(file, maxW=1280, maxH=1280, quality=0.72){
      if(!file) return null;
      const img = await new Promise((res,rej)=>{
        const reader = new FileReader();
        reader.onload = ()=>{
          const i = new Image();
          i.onload = ()=> res(i);
          i.onerror = rej;
          i.src = reader.result;
        };
        reader.onerror = rej;
        reader.readAsDataURL(file);
      });
      const width = img.width;
      const height = img.height;
      const ratio = Math.min(maxW / width, maxH / height, 1);
      const w = Math.round(width * ratio);
      const h = Math.round(height * ratio);
      const canvas = document.createElement('canvas');
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d', { alpha:false });
      ctx.drawImage(img, 0, 0, w, h);
      return canvas.toDataURL('image/jpeg', quality);
    }

    function fileToDataURL(file){ return new Promise((resolve,reject)=>{
      if(!file) return resolve(null);
      const r = new FileReader();
      r.onload = ()=> resolve(r.result);
      r.onerror = reject; r.readAsDataURL(file);
    });}

    // GeolocalizaciÃ³n rÃ¡pida: primer fix con watchPosition (mejor para mÃ³viles)
    function getGPSFast(){
      return new Promise((resolve,reject)=>{
        if(!navigator.geolocation) return reject(new Error("GeolocalizaciÃ³n no disponible"));
        let done = false;
        const opts = { enableHighAccuracy:true, timeout:15000, maximumAge:30000 };
        const id = navigator.geolocation.watchPosition(function(pos){
          if(done) return;
          done = true;
          try{ navigator.geolocation.clearWatch(id); }catch(_){}
          resolve({ lat:pos.coords.latitude, lng:pos.coords.longitude, ts:Date.now(), acc:pos.coords.accuracy });
        }, function(err){
          if(done) return;
          done = true;
          try{ navigator.geolocation.clearWatch(id); }catch(_){}
          reject(err);
        }, opts);
        setTimeout(function(){
          if(!done){
            done = true;
            try{ navigator.geolocation.clearWatch(id); }catch(_){}
            reject(new Error('timeout'));
          }
        }, 16000);
      });
    }

    function markerPopupHtml(p, titulo, fotoDataUrl, meta){
      var imgHtml = fotoDataUrl
        ? '<img class="popup-img" src="' + fotoDataUrl + '" alt="foto"/>'
        : '<div class="popup-meta">Sin foto</div>';
      return (
        '<div style="min-width:220px">' +
          '<div class="popup-title">' + titulo + '</div>' +
          '<div class="popup-meta">Lat: ' + p.lat.toFixed(6) + ' &middot; Lng: ' + p.lng.toFixed(6) + (p.acc ? ' â€¢ Â±' + Math.round(p.acc) + 'm' : '') + '</div>' +
          '<div class="popup-meta">' + meta + '</div>' +
          imgHtml +
        '</div>'
      );
    }

    function drawItem(it, fit){
      var col = tipoColor(it.tipo);

      // LÃ­nea
      var line = L.polyline(
        [
          [it.inicio.lat, it.inicio.lng],
          [it.fin.lat, it.fin.lng]
        ],
        { color: col, weight: 5, opacity: 0.95 }
      );
      addLayer(line);

      // Marcador inicio
      var mkIni = L.circleMarker([it.inicio.lat, it.inicio.lng], { radius:7, color:col, fillColor:col, fillOpacity:0.95 });
      mkIni.bindPopup(function(){
        return markerPopupHtml(it.inicio, 'INICIO â€” ' + it.circuito, it.fotoInicio, it.sector + ' â€¢ ' + it.subestacion + ' â€¢ ' + it.tipo);
      });
      addLayer(mkIni);

      // Marcador final
      var mkFin = L.circleMarker([it.fin.lat, it.fin.lng], { radius:7, color:col, fillColor:col, fillOpacity:0.95 });
      mkFin.bindPopup(function(){
        return markerPopupHtml(it.fin, 'FINAL â€” ' + it.circuito, it.fotoFin, it.sector + ' â€¢ ' + it.subestacion + ' â€¢ ' + it.tipo);
      });
      addLayer(mkFin);

      // Click en la lÃ­nea abre resumen
      line.on("click", function(){
        var mid = [(it.inicio.lat + it.fin.lat)/2, (it.inicio.lng + it.fin.lng)/2];
        var html = ''
          + '<div style="min-width:240px">'
          +   '<div class="popup-title">' + it.sector + ' â€¢ ' + it.subestacion + '</div>'
          +   '<div class="popup-meta">Circuito: <b>' + it.circuito + '</b> â€” <span style="color:' + col + '">' + it.tipo + '</span></div>'
          +   '<div class="popup-meta">' + new Date(it.createdAt).toLocaleString() + '</div>'
          +   '<div class="popup-meta">Inicio: ' + it.inicio.lat.toFixed(6) + ', ' + it.inicio.lng.toFixed(6) + '</div>'
          +   '<div class="popup-meta">Final: ' + it.fin.lat.toFixed(6) + ', ' + it.fin.lng.toFixed(6) + '</div>'
          +   (it.fotoInicio ? '<div style="margin-top:6px">Foto inicio:</div><img class="popup-img" src="' + it.fotoInicio + '"/>' : '')
          +   (it.fotoFin ? '<div style="margin-top:6px">Foto final:</div><img class="popup-img" src="' + it.fotoFin + '"/>' : '')
          + '</div>';
        L.popup().setLatLng(mid).setContent(html).openOn(map);
      });

      if(fit){
        var b = L.latLngBounds([[it.inicio.lat,it.inicio.lng],[it.fin.lat,it.fin.lng]]);
        map.fitBounds(b.pad(0.3));
      }
    }

    function renderAll(){
      clearMapLayers();
      (state.items||[]).forEach(function(it){ drawItem(it, false); });
    }

    function clearWizard(resetAll){
      if (typeof resetAll === "undefined") resetAll = true;
      if(resetAll){
        state.actual = { sector:"", subestacion:"", circuito:"", tipo:"Apertura", inicio:null, fin:null, fotoInicio:null, fotoFin:null };
      } else {
        state.actual.inicio = null; state.actual.fin = null; state.actual.fotoInicio = null; state.actual.fotoFin = null;
      }
      $("sector").value = ""; $("subestacion").value=""; $("circuito").value="";
      $("tipo").value = "Apertura";
      $("fotoInicio").value = ""; $("fotoFin").value = "";
      $("previewInicioWrap").classList.add("hidden");
      $("previewFinWrap").classList.add("hidden");
      $("previewInicio").src = ""; $("previewFin").src = "";
    }

    function validateStep1(){
      var sector = $("sector").value.trim();
      var sub = $("subestacion").value.trim();
      var circ = $("circuito").value.trim();
      if(!sector || !sub || !circ) return false;
      state.actual.sector = sector; state.actual.subestacion = sub; state.actual.circuito = circ;
      state.actual.tipo = $("tipo").value;
      return true;
    }

    async function validateStep2(){
      if(!state.actual.inicio){
        try { await capInicio(); } catch (e) {}
      }
      var f = $("fotoInicio").files[0];
      if(!state.actual.inicio || !f) return false;
      state.actual.fotoInicio = await compressImage(f, 1280, 1280, 0.72);
      $("previewInicio").src = state.actual.fotoInicio; $("previewInicioWrap").classList.remove("hidden");
      return true;
    }

    async function validateStep3(){
      if(!state.actual.fin){
        try { await capFin(); } catch (e) {}
      }
      var f = $("fotoFin").files[0];
      if(!state.actual.fin || !f) return false;
      state.actual.fotoFin = await compressImage(f, 1280, 1280, 0.72);
      $("previewFin").src = state.actual.fotoFin; $("previewFinWrap").classList.remove("hidden");
      return true;
    }

    function fillResumen(){
      var it = state.actual;
      var col = tipoColor(it.tipo);
      $("resumen").innerHTML =
        '<div class="grid">'
        + '<div><b>Sector:</b> ' + it.sector + '</div>'
        + '<div><b>SubestaciÃ³n:</b> ' + it.subestacion + '</div>'
        + '<div><b>Circuito:</b> ' + it.circuito + '</div>'
        + '<div><b>Tipo:</b> <span style="color:' + col + '">' + it.tipo + '</span></div>'
        + '<div><b>Inicio:</b> ' + (it.inicio ? it.inicio.lat.toFixed(6)+', '+it.inicio.lng.toFixed(6) : '-') + '</div>'
        + '<div><b>Final:</b> ' + (it.fin ? it.fin.lat.toFixed(6)+', '+it.fin.lng.toFixed(6) : '-') + '</div>'
        + '<div><b>Foto inicio:</b></div>'
        + (it.fotoInicio ? '<img class="preview" src="' + it.fotoInicio + '"/>' : '<div class="note">Sin foto</div>')
        + '<div><b>Foto final:</b></div>'
        + (it.fotoFin ? '<img class="preview" src="' + it.fotoFin + '"/>' : '<div class="note">Sin foto</div>')
        + '</div>';
    }

    // ====== Capturas (con mejor UX y rapidez) ======
    async function capInicio(){
      showBlocker('Obteniendo GPS (inicio)â€¦');
      try{
        const p = await getGPSFast();
        state.actual.inicio = p;
        if (state.mkInicioTemp) { try { map.removeLayer(state.mkInicioTemp); } catch(_){ /* ignore */ } }
        const mk = L.marker([p.lat,p.lng], { title:"Inicio (ajustable)", draggable:true }).bindPopup("Arrastra para ajustar inicio");
        mk.on("dragend", function(e){
          const ll = e.target.getLatLng();
          state.actual.inicio = { lat: ll.lat, lng: ll.lng, ts: Date.now() };
        });
        addLayer(mk);
        state.mkInicioTemp = mk;
        mk.openPopup();
        toast('Punto inicial capturado.');
      } finally { hideBlocker(); }
    }

    async function capFin(){
      showBlocker('Obteniendo GPS (final)â€¦');
      try{
        const p = await getGPSFast();
        state.actual.fin = p;
        if (state.mkFinTemp) { try { map.removeLayer(state.mkFinTemp); } catch(_){ /* ignore */ } }
        const mk = L.marker([p.lat,p.lng], { title:"Final (ajustable)", draggable:true }).bindPopup("Arrastra para ajustar final");
        mk.on("dragend", function(e){
          const ll = e.target.getLatLng();
          state.actual.fin = { lat: ll.lat, lng: ll.lng, ts: Date.now() };
        });
        addLayer(mk);
        state.mkFinTemp = mk;
        mk.openPopup();
        toast('Punto final capturado.');
      } finally { hideBlocker(); }
    }

    // ====== Guardado & Sync robusto ======
    function safeSetLocal(key, value){
      try{
        localStorage.setItem(key, value);
        return true;
      }catch(e){
        console.warn('No se pudo guardar en localStorage:', e);
        toast('âš ï¸ Memoria local llena. Considera sincronizar pronto.');
        return false;
      }
    }

    async function fetchJSON(url, payload, opts){
      const options = opts || {};
      const timeoutMs = options.timeoutMs || 15000;
      const retries = options.retries != null ? options.retries : 1;
      const ctrl = new AbortController();
      const t = setTimeout(function(){ try{ ctrl.abort(); }catch(_){ } }, timeoutMs);
      try{
        const res = await fetch(url, { ...payload, signal: ctrl.signal });
        if(!res.ok) throw new Error('HTTP ' + res.status);
        return await res.json();
      }catch(e){
        if(retries>0) return fetchJSON(url, payload, {timeoutMs:timeoutMs, retries:retries-1});
        throw e;
      }finally{ clearTimeout(t); }
    }

    async function syncToSheet(pendientes){
      if(!APPS_SCRIPT_URL) return { ok:false, error:"Sin URL" };
      const payload = { records: pendientes };
      return await fetchJSON(APPS_SCRIPT_URL, {
        method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(payload)
      }, { timeoutMs: 20000, retries: 1 });
    }

    // ====== Eventos de UI ======
    $("newTramo").onclick = function(){ openSheet(); setStep(1); };
    $("s1-cancel").onclick = closeSheet;
    $("s1-next").onclick = function(){
      if(!validateStep1()){ toast("Completa Sector, SubestaciÃ³n y Circuito."); return; }
      setStep(2);
    };
    $("s2-back").onclick = function(){ setStep(1); };
    $("s2-next").onclick = async function(){
      const ok = await validateStep2();
      if(!ok){ toast("Captura el punto inicial y selecciona una foto."); return; }
      setStep(3);
    };
    $("s3-back").onclick = function(){ setStep(2); };
    $("s3-next").onclick = async function(){
      const ok = await validateStep3();
      if(!ok){ toast("Captura el punto final y selecciona una foto."); return; }
      fillResumen();
      setStep(4);
    };
    $("s4-cancel").onclick = function(){ closeSheet(); };

    $("s4-save").onclick = async function(){
      const btn = $("s4-save"); btn.disabled = true;

      const it = {
        id: (crypto && crypto.randomUUID) ? crypto.randomUUID() : String(Date.now()) + '-' + Math.random().toString(16).slice(2),
        sector: state.actual.sector,
        subestacion: state.actual.subestacion,
        circuito: state.actual.circuito,
        tipo: state.actual.tipo,
        inicio: state.actual.inicio,
        fin: state.actual.fin,
        fotoInicio: state.actual.fotoInicio,
        fotoFin: state.actual.fotoFin,
        createdAt: new Date().toISOString(),
        synced: false
      };
      state.items.push(it);
      safeSetLocal("brechas_items", JSON.stringify(state.items));
      drawItem(it, true);
      closeSheet();
      try{ if(state.mkInicioTemp){ map.removeLayer(state.mkInicioTemp); state.mkInicioTemp=null; } }catch(_){}
      try{ if(state.mkFinTemp){ map.removeLayer(state.mkFinTemp); state.mkFinTemp=null; } }catch(_){}
      renderAll();
      updatePendingUI();

      showBlocker('Guardando y sincronizandoâ€¦');
      let ok = false;
      try {
        const pendientes = state.items.filter(function(x){ return !x.synced; });
        if (pendientes.length) {
          const data = await syncToSheet(pendientes);
          const okIds = new Set([].concat(data.syncedIds || [], data.alreadySyncedIds || []));
          const urlMap = data.urlMap || {};
          state.items = state.items.map(function(x){
            if (okIds.has(x.id)) {
              const urls = urlMap[x.id] || {};
              return Object.assign({}, x, { synced:true, fotoInicioUrl: urls.inicio || x.fotoInicioUrl || null, fotoFinUrl: urls.fin || x.fotoFinUrl || null });
            }
            return x;
          });
          safeSetLocal("brechas_items", JSON.stringify(state.items));
          renderAll();
          updatePendingUI();
        }
        ok = true;
      } catch (e) {
        console.warn("Autosync fallÃ³, queda pendiente:", e);
      } finally {
        hideBlocker();
        toast(ok ? "InformaciÃ³n guardada correctamente" : "Guardado local OK, sincronizaciÃ³n pendiente.");
        btn.disabled = false;
      }
    };

    // Botones de captura
    $("cap-inicio").onclick = capInicio;
    $("cap-fin").onclick = capFin;

    // Previews (ya comprimidos en validate*)
    $("fotoInicio").addEventListener("change", async function(e){
      if(e.target.files[0]){
        const url = await compressImage(e.target.files[0], 960, 960, 0.7);
        $("previewInicio").src = url; $("previewInicioWrap").classList.remove("hidden");
      }
    });
    $("fotoFin").addEventListener("change", async function(e){
      if(e.target.files[0]){
        const url = await compressImage(e.target.files[0], 960, 960, 0.7);
        $("previewFin").src = url; $("previewFinWrap").classList.remove("hidden");
      }
    });

    window.syncBrechas = async function(){
      const pendientes = (state.items||[]).filter(function(it){ return !it.synced; });
      if(!pendientes.length){ toast("No hay reportes pendientes."); return; }
      showBlocker('Sincronizandoâ€¦');
      try{
        const data = await syncToSheet(pendientes);
        const okIds = new Set([].concat(data.syncedIds || [], data.alreadySyncedIds || []));
        const urlMap = data.urlMap || {};
        state.items = state.items.map(function(it){
          if(okIds.has(it.id)){
            const urls = urlMap[it.id] || {};
            return Object.assign({}, it, { synced:true, fotoInicioUrl: urls.inicio || it.fotoInicioUrl || null, fotoFinUrl: urls.fin || it.fotoFinUrl || null });
          }
          return it;
        });
        safeSetLocal("brechas_items", JSON.stringify(state.items));
        renderAll();
        updatePendingUI();
        toast("âœ… SincronizaciÃ³n completa");
      } catch(e){ console.error(e); toast("âŒ Error al sincronizar"); }
      finally{ hideBlocker(); }
    };

    // Abrir previews en grande al tocar
    document.addEventListener('click', function(e){
      const el = e.target;
      if (el && el.classList && el.classList.contains('preview')) {
        try { window.open(el.src, '_blank'); } catch(_) {}
      }
    });

    // === Pending sync UI helpers ===
    function getPendingCount(){
      try { return (state.items || []).filter(function(it){ return !it.synced; }).length; } catch (e) { return 0; }
    }
    function updatePendingUI(){
      const n = getPendingCount();
      const badge = document.getElementById("pendingBadge");
      const banner = document.getElementById("pendingBanner");
      const countEl = document.getElementById("pendingCount");
      if(badge){
        if(n>0){ badge.style.display='inline-block'; badge.textContent = n + ' pendiente(s)'; }
        else { badge.style.display='none'; }
      }
      if(banner){
        if(n>0){ banner.style.display='block'; if(countEl) countEl.textContent = n; }
        else { banner.style.display='none'; }
      }
    }
    const syncBtn = document.getElementById("syncBtn");
    if(syncBtn){
      syncBtn.addEventListener("click", async function(){
        const n = getPendingCount();
        if(n===0){ toast("No hay reportes pendientes."); return; }
        await window.syncBrechas();
      });
    }

    // ====== UI helpers ======
    function toast(msg){
      let t = document.getElementById('toast');
      if(!t){ t = document.createElement('div'); t.id='toast'; t.className='toast'; document.body.appendChild(t); }
      t.textContent = msg;
      t.style.display='block';
      setTimeout(function(){ t.style.display='none'; }, 3000);
    }
    function showBlocker(text){
      const el = document.getElementById('blocker');
      const tx = document.getElementById('blockerText');
      if(tx) tx.textContent = text || 'Sincronizandoâ€¦';
      if(el) el.style.display = 'flex';
    }
    function hideBlocker(){
      const el = document.getElementById('blocker');
      if(el) el.style.display = 'none';
    }
  </script>

  <div id="blocker" class="blocker" aria-hidden="true">
    <div class="box"><span class="spinner"></span><span id="blockerText">Guardandoâ€¦</span></div>
  </div>

<!-- Injected online-first sync layer 2025-10-21T20:23:46.268002Z -->
<script>
(() => {
  // ===== CONFIG =====
  const API_URL = (window.BRECHAS_API_URL || '/api/sync'); // your proxy to Apps Script
  const LS_KEY = 'brechas_pend';
  const MAX_PEND = 8;

  // ===== HELPERS =====
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));
  const $ = (id) => document.getElementById(id);
  const toast = window.toast || ((msg) => console.log('[toast]', msg));

  function lsGet(key, fallback) {
    try { return JSON.parse(localStorage.getItem(key)) ?? fallback; }
    catch { return fallback; }
  }
  function lsSet(key, val) {
    const s = JSON.stringify(val);
    localStorage.setItem(key, s); // may throw on quota
  }
  function actualizarBadgePendientes(n) {
    const el = document.querySelector('[data-pendientes-badge]');
    if (!el) return;
    el.textContent = String(n);
    el.style.display = n ? 'inline-flex' : 'none';
  }
  function genId() {
    return (crypto.randomUUID?.() || 'id-' + Date.now() + '-' + Math.random().toString(16).slice(2));
  }

  async function comprimirFoto(fileOrBlob, maxDim=960, quality=0.5) {
    const url = URL.createObjectURL(fileOrBlob);
    const img = await new Promise((res, rej) => {
      const i = new Image(); i.onload = () => res(i); i.onerror = rej; i.src = url;
    });
    URL.revokeObjectURL(url);
    const W = img.naturalWidth, H = img.naturalHeight;
    const r = Math.max(W,H) > maxDim ? (W>H ? maxDim/W : maxDim/H) : 1;
    const w = Math.round(W*r), h = Math.round(H*r);
    const canvas = document.createElement('canvas');
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d', { willReadFrequently: false });
    ctx.drawImage(img, 0, 0, w, h);
    let dataURL = canvas.toDataURL('image/jpeg', quality);
    const size = ((dataURL.split(',')[1]||'').length * 3) >> 2;
    if (size > 200*1024) dataURL = canvas.toDataURL('image/jpeg', 0.4);
    return dataURL;
  }

  async function postAPI(records, { timeoutMs=12000, retries=1 }={}) {
    const body = JSON.stringify({ records });
    let intento = 0, lastErr;
    while (intento <= retries) {
      try {
        const ctrl = new AbortController();
        const t = setTimeout(() => ctrl.abort(), timeoutMs);
        const resp = await fetch(API_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body,
          signal: ctrl.signal
        });
        clearTimeout(t);
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        const json = await resp.json();
        if (!json?.ok) throw new Error(json?.error || 'Respuesta no OK');
        return json;
      } catch (e) {
        lastErr = e;
        if (navigator.onLine === false) break;
        if (intento === retries) break;
        await sleep(600 * (intento+1));
        intento++;
      }
    }
    throw lastErr || new Error('fallo de red');
  }

  function addPendienteLocal(item) {
    let arr = lsGet(LS_KEY, []);
    arr.push(item);
    try { lsSet(LS_KEY, arr); }
    catch (e) {
      // try drop oldest
      arr.shift();
      lsSet(LS_KEY, arr);
      toast('Se removiÃ³ el pendiente mÃ¡s antiguo para liberar espacio.');
    }
    actualizarBadgePendientes(arr.length);
  }

  async function intentarSincronizarPendientes() {
    if (!navigator.onLine) return;
    let arr = lsGet(LS_KEY, []);
    if (!arr.length) return;
    document.documentElement.setAttribute('data-syncing','1');
    const restantes = [];
    for (const it of arr) {
      try {
        const resp = await postAPI([{ 
          id: it.id,
          sector: it.sector,
          subestacion: it.subestacion,
          circuito: it.circuito,
          tipo: it.tipo,
          inicio: it.inicio,
          fin: it.fin,
          fotoInicio: it.fotoInicio || undefined,
          fotoFin: it.fotoFin || undefined,
          createdAt: it.createdAt
        }]);
        const urls = resp?.urlMap?.[it.id] || {};
        // hook UI if present
        if (window.marcarEnUIComoSynced) window.marcarEnUIComoSynced(it.id, urls);
      } catch (e) {
        restantes.push(it);
      }
    }
    lsSet(LS_KEY, restantes);
    actualizarBadgePendientes(restantes.length);
    document.documentElement.removeAttribute('data-syncing');
    toast(restantes.length ? `Quedan ${restantes.length} pendientes` : 'Todo sincronizado âœ…');
  }

  window.addEventListener('online', intentarSincronizarPendientes);

  // ===== Public API (attach to window to avoid cross-function issues) =====
  window.BrechasSync = {
    async guardarOnlineFirst(tramo, archivos) {
      // archivos: { inicio: File|Blob|null, fin: File|Blob|null }
      // 1) Comprimir (estÃ¡ndar)
      let fotoInicio = null, fotoFin = null;
      if (archivos?.inicio) fotoInicio = await comprimirFoto(archivos.inicio, 960, 0.5);
      if (archivos?.fin)    fotoFin   = await comprimirFoto(archivos.fin,    960, 0.5);
      const id = (tramo.id || genId());
      const createdAt = tramo.createdAt || new Date().toISOString();
      const record = { id,
        sector: tramo.sector, subestacion: tramo.subestacion, circuito: tramo.circuito, tipo: tramo.tipo,
        inicio: tramo.inicio, fin: tramo.fin,
        fotoInicio: fotoInicio || undefined, fotoFin: fotoFin || undefined,
        createdAt
      };
      // 2) Intentar subir primero
      try {
        const resp = await postAPI([record], { timeoutMs: 12000, retries: 1 });
        const urls = resp?.urlMap?.[id] || {
          inicio: record.fotoInicioUrl || '', fin: record.fotoFinUrl || ''
        };
        // Marca UI como sincronizado si tienes funciÃ³n
        if (window.marcarEnUIComoSynced) window.marcarEnUIComoSynced(id, urls);
        toast('Subido âœ…');
        return { ok:true, online:true, id, urls };
      } catch (e) {
        // 3) Fallback local
        const itemLocal = Object.assign({ synced:false }, record);
        try {
          // Control de cuota: mÃ¡x MAX_PEND
          let arr = lsGet(LS_KEY, []);
          if (arr.length >= MAX_PEND) {
            // intentar guardar removiendo el mÃ¡s antiguo
            arr.shift();
            lsSet(LS_KEY, arr);
          }
          addPendienteLocal(itemLocal);
          toast('Guardado local âš ï¸. Subiremos cuando vuelva internet.');
          return { ok:true, online:false, id };
        } catch (err) {
          alert('No hay espacio para guardar sin conexiÃ³n. Elimina pendientes o reduce fotos.');
          return { ok:false, error: 'localStorage full' };
        }
      }
    },
    syncPendientes: intentarSincronizarPendientes,
    pendientesCount() { return lsGet(LS_KEY, []).length; }
  };

  // ===== Try to wire Save button if known IDs exist =====
  document.addEventListener('DOMContentLoaded', () => {
    actualizarBadgePendientes(lsGet(LS_KEY, []).length);
    const btnSync = document.querySelector('[data-action="sync-pendientes"]');
    if (btnSync) btnSync.addEventListener('click', () => window.BrechasSync.syncPendientes());
  });
})();
</script>

</body>
</html>
